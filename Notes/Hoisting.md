Hoisting.

One of the key features of JS is hoisting. Let's dive deep into this concept, to understand how it really  works.
In JS, variables and functions declared are hoisted enabling you to use them before we even declare them.
By hoisted, it means they come at top of their scope.
>A undeclared variable, is always of the type undefined, during execution.
<pre>console.log(typeof(myCar)); //undefined
console.log(myCar)l // Uncaught ReferenceError: myCar is not defined
</pre>

What happens under the hood is, when JS engine processes our code, execution context is created- the creation phase where variables  and functions declarations  are added to our computer's memory, but doesnt assign them any value and the execution phase where values are assigned to them(var added with undefined). So whenevr functions/variables are execuited before we even use them thats becauise during the creation pghase they get stored in the memory, so our JS engine already knows where tjhe variables and the functions are sitting in the memory.
FOr var, wghen declared, the JS engine adds a placeholder value ton it that is undeifned
During the execution, myCar, that has not been declared also, will get value, undefined and it's type will also be undefined. When we will try to log the undeclared variable it will throw the Reference Error as shown above, as we are trying to access the undeclared variable.
 THE JS interpretr is sayimng that the variable was nowhere found in the memroy,not defiend
Let's understand more, with another example.
<pre>console.log(a) // undefined
var a = 1;</pre>

It results in printing undefined rather than throwing error as the variable is being hoisted to the top, the value or the assignments does not gets hoisted as it is assigned after the logging has been done.
Therefore, `var a` will get hoisted at the top, then the logging part will execute, giving us undefined, after that, the value 1 will be assigned to a. That is how our code will look like to interpreter.
<pre>
var a;
console.log(a)
a= 1;
</pre> 
Another key thing to remember is, when assigning value to an undeclared variable, implicitely create it as a global variable, when executed.  
<pre>
console.log(hoist);
let hoist = 10 //ReferenceError: hoist is not defined
</pre>
### Function Scoped
The function declaration are hoisted completely to the top, enabling us to invoke the function before declaring it.

<pre>test()  //1
function test(){
    console.log(1)
}</pre>
In the above example the function declaration is hoisted to the very top, therefore giving us the desired output.
<pre>
function checkHoist(){
    a = 20;
    var b = 30;
}
>
checkHoist();
console.log("a is global variable", a)//a is global variable 20
console.log(b) //ReferenceError: b is not defined
</pre>
>For accessing the undeclared variable, code within which it is being assigned should execute, else it will throw error.
We cannot access b outside of it's scope.
> Arrow functions, function expression does not gets hoisted.
Let's take a look on function scoped variable are scoped.
<pre>
function checkHoisting(){
    console.log(b) //undefined
    var b = 10;
}
checkHoisting()
</pre>
In the above example, output will be undefined.
This is how interpreter will view the code.
<pre>
function checkHoisting(){
    var b;
    console.log(b) 
     b = 10;
}
checkHoisting()
</pre>
the variable b will be hoisted at the top of its scope, thus giving us undefined.
<pre>
foo() //Uncaught ReferenceError: Cannot access 'foo' before initialization
const foo = () =>{
    console.log(12)
}</pre>

<pre>foo() //Uncaught TypeError: foo is not a function
var foo = function(){
    console.log("no hoisting")
}</pre>
In the above example we get a type error as var foo is hoisted but type of foo is not known yet, as the assignment to a function is not hoisted.
> Function declaration are hoisted over variable declaration but not over variable assignment.
Reading this might be confusing at first, let's understand with example
#### Variable assignment over function declaration
<pre>
var name = 'Mary'
function name(){
        return 'Blob'
}
console.log(typeof(name)) //string
</pre>
#### Function declaration over variable declaration
<pre>
var name
function name(){
        return 'Blob'
}
console.log(typeof(name)) //function
</pre>
### Hoisting classes
classes can be classified either class declaration or class expression-
class declaration- They are also hoisted but remain uninitiased until evaluation, leading you to declare classes before accessing them.
<pre>
    var car = new Car();//ReferenceError: Cannot access 'Car' before initialization
car.color='blue';
car.model=' Honda City'
console.log(car)
class Car{
    constructor(color,model){
        this.color=color;
        this.model=model
    }
}
</pre>
It leads to the believe that to access the class properties, we need to it declare it first
your linter will display the message 
Class 'Car' used before its declaration.
<pre>
class Car{
    constructor(color,model){
        this.color=color;
        this.model=model
    }
}
    var car = new Car();//ReferenceError: Cannot access 'Car' before initialization
car.color='blue';
car.model=' Honda City'
console.log(car) Car {color: "blue", model: " Honda City"}
</pre>
#### Class expression
class expression are not hoisted.
let's see it with an example-

<pre>var car = new Car(); // Car is not a constructor
car.color='blue';
car.model='honda city'

var Car = class{
     constructor(color,model){
        this.color=color;
        this.model=model
    }
}</pre>
Correct way to implement this is-
<pre>var Car = class{
     constructor(color,model){
        this.color=color;
        this.model=model
    }
}
    var car = new Car(); // Car is not a constructor
car.color='blue';
car.model='honda city'
console.log(car) //Car {color: "blue", model: "honda city"}
</pre>
#### let and const
with the introduction of new changes in ES+ comes let and const.
variables dclared with the let keyword are block scoped. They also get hoisted but remain unitialised until their assignment is evaluated runtime by js engine.
During the compilation, variable a gets stored in the memory, but it will not get initialised with any value. WHen we tried to access the uninitialised  variable, reference error will be thrown
Which means we cannot access the variable until its value is evaluate by the engine.
If it cannot find the value of let or const variables, where they are declared, undefined will be assigned to them.
<pre>let car;
console.log(car); //undefined
car= 6;</pre>
During the compilation, variable a gets stored in the memory, it will get initialised when during run time their assignment is evaluated. During run time when engine reached the line of code, where it is declared, it will try to evaluate its assignment, but since it has not value that time, undefined will be assigned. After that 6 will be assigned and the value will be updated.
let and const are initialised only in the execution phase. The time between declaration of variable and initialisation is temporal dead zone and accessing within this window, will throw referemnce error.
accessing let or const variable before its declaration causes refrence error,accessing varioable in the temporal dead zone will give refernce error. Therefore, being able to access a variable before its declaration is starnge, therefore temporaldeasd zone is necessary so tjhat it could warn us
Caveat-
There is an argument over whether let and const are actually hoisted or not. Some believe that
They are hoisted but not assigned a value 'undefined' in compilation phase of the execution context(scope of variable decalared is its current execution context) that is they are hoisted but remain unitialised.
They get stored in the memory, so during execution phase JS engine already knows where the variables and function declared are stored in memory
<pre>
var teacher = 'Alice'
function printName(){
    console.log(teacher); //Reference error:Cannot access 'teacher' before initialisation
    let teacher='Bob'
}</pre>


Conclusion  
1. Always declare and initialise the variable before using them.
2. Use let and const whenever possible.
3. To avoid the pitfalls caused by the hoisting, it is strongly adviced to use `'use strict'`



























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































